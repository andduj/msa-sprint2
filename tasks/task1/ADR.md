# ADR: Архитектурный анализ и план миграции Hotelio на микросервисы

### <a name="_b7urdng99y53"></a>**Название задачи:** 
Подготовка архитектурного анализа и плана начала миграции на микросервисы для системы Hotelio

### <a name="_hjk0fkfyohdk"></a>**Автор:**
Команда разработки Hotelio

### <a name="_uanumrh8zrui"></a>**Дата:**
03.08.2025

### <a name="_3bfxc9a45514"></a>**Функциональные требования**

|**№**|**Действующие лица или системы**|**Use Case**|**Описание**|
| :-: | :- | :- | :- |
|1|Пользователь|Бронирование отеля|Пользователь выбирает отель, вводит данные, применяет промокод, система валидирует данные и создает бронирование|
|2|Пользователь|Просмотр отелей|Пользователь ищет отели по городу, просматривает рейтинги и отзывы|
|3|Пользователь|Управление профилем|Пользователь просматривает свои бронирования, статус аккаунта|
|4|Система|Валидация промокодов|Система проверяет действительность промокода, применимость к пользователю|
|5|Система|Управление отзывами|Система собирает отзывы, рассчитывает рейтинги, определяет доверие к отелю|
|6|Система|Управление пользователями|Система проверяет статус пользователя, блэклист, VIP-статус|

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

|**№**|**Требование**|
| :-: | :- |
|1|Масштабируемость - система должна поддерживать рост нагрузки на отдельные компоненты|
|2|Отказоустойчивость - отказ одного компонента не должен приводить к падению всей системы|
|3|Независимость разработки - команды должны иметь возможность разрабатывать компоненты независимо|
|4|Производительность - время ответа API не должно превышать 500ms|
|5|Надежность - система должна обеспечивать 99.9% доступности|
|6|Безопасность - валидация данных на всех уровнях|

### <a name="_qmphm6d6rvi3"></a>**Решение**

#### Контекст компании

**Hotelio** — онлайн-платформа для бронирования отелей и апартаментов с:
- ~1 млн зарегистрированных пользователей
- Основной трафик на поиск и бронирование жилья
- Java-монолит с API для клиентов и партнёрских каналов

**Проблематика:**
Сервис Hotelio реализован как единое приложение, в котором все бизнес-функции собраны в одном коде, разворачиваются как единый сервис и используют одну базу данных. С ростом бизнеса возникли серьёзные архитектурные и операционные проблемы. Команда приняла решение о переходе на микросервисную архитектуру с постепенным выносом сервисов.

**IT-отдел:**
- 2 разработчика на Java
- Архитектор (пишет код)
- Фронтенд-разработчик
- DevOps-инженер
- Тестировщик
- Продукт-менеджер

**Текущая инфраструктура:**
- Java Spring Boot (монолит и сервисы)
- PostgreSQL
- Kafka
- Docker

#### Текущая архитектура (AS-IS)

Система Hotelio представляет собой монолитное Spring Boot приложение со следующей структурой:

**Компоненты:**
- **Controllers**: BookingController, HotelController, ReviewController, UserController, PromoCodeController
- **Services**: BookingService, HotelService, ReviewService, UserService, PromoCodeService
- **Repository**: JPA репозитории для работы с PostgreSQL
- **Entity**: JPA сущности для всех доменных объектов

**Критические проблемы текущей архитектуры:**

1. **Сложность сопровождения**
   - Любое изменение требует понимания всей кодовой базы
   - Невозможно менять один модуль, не затрагивая другие

2. **Низкая масштабируемость**
   - При пиковых нагрузках, например на бронирование, нельзя масштабировать только нужный компонент
   - Производительность неравномерна

3. **Невозможность гибкой разработки**
   - Разные команды не могут работать независимо
   - Трудно внедрить быстрый CI/CD

4. **Ограничения на фронтенде**
   - REST API монолита слишком универсален и плохо адаптируется под разные платформы
   - Нет поддержки BFF

5. **Сложности с запуском новых фичей**
   - Большой риск ошибок из-за плотной связанности
   - Тестирование требует понимания всех зависимостей

#### Целевая архитектура (TO-BE)

**Принципы миграции:**
1. **Strangler Fig Pattern** - постепенная замена компонентов
2. **Domain-Driven Design** - выделение доменных границ
3. **Event-Driven Architecture** - асинхронная коммуникация
4. **API Gateway** - единая точка входа
5. **Service Mesh** - управление трафиком и безопасностью

**План миграции:**

**Этап 1: Подготовка инфраструктуры (2-3 месяца)**
- Настройка Docker и Kubernetes для контейнеризации
- Внедрение базового мониторинга (Prometheus + Grafana)
- Настройка CI/CD пайплайнов (GitLab CI)
- Обучение команды основам микросервисной архитектуры

**Этап 2: Вынос первого сервиса - Booking Service (3-4 месяца)**
- Создание отдельного сервиса для бронирований
- Реализация gRPC API для внутренней коммуникации
- Настройка синхронной коммуникации с монолитом
- Внедрение Circuit Breaker для отказоустойчивости
- Постепенное перенаправление трафика (10% → 50% → 100%)

**Этап 3: Постепенная миграция остальных сервисов (6-8 месяцев)**
- User Service (управление пользователями)
- Hotel Service (информация об отелях)
- Review Service (отзывы и рейтинги)
- Promo Service (промокоды и скидки)

**Этап 4: Оптимизация и масштабирование (2-3 месяца)**
- Внедрение асинхронной коммуникации через Kafka
- Оптимизация производительности
- Настройка автоматического масштабирования
- Внедрение API Gateway для единой точки входа

### <a name="_bjrr7veeh80c"></a>**Альтернативы**

**Альтернатива 1: Big Bang Migration**
- Полная переписывание системы с нуля
- **Плюсы**: чистая архитектура, современные технологии
- **Минусы**: высокий риск, длительное время разработки, сложность тестирования

**Альтернатива 2: Database per Service**
- Разделение базы данных по сервисам
- **Плюсы**: полная изоляция данных
- **Минусы**: сложность миграции данных, нарушение ACID транзакций

**Альтернатива 3: Shared Database**
- Общая база данных для всех сервисов
- **Плюсы**: простота реализации, сохранение транзакций
- **Минусы**: слабая изоляция, риск нарушения принципов микросервисов

### **Недостатки, ограничения, риски**

**Недостатки выбранного решения:**
1. **Сложность отладки** - распределенная система сложнее в отладке
2. **Сетевые задержки** - межсервисная коммуникация добавляет латентность
3. **Сложность развертывания** - больше компонентов для управления
4. **Дублирование кода** - общие библиотеки и утилиты

**Ограничения:**
1. **Ресурсы** - небольшая команда (6 человек), включая архитектора
2. **Время** - необходимость поддержки старой системы во время миграции
3. **Технологии** - зависимость от существующего стека (Java Spring Boot, PostgreSQL, Kafka)
4. **Опыт** - команда имеет опыт только с монолитной архитектурой
5. **Бизнес-критичность** - система обслуживает 1 млн пользователей, нельзя допустить простоя

**Риски:**
1. **Риск потери данных** при миграции
2. **Риск снижения производительности** на начальных этапах
3. **Риск усложнения системы** без достижения преимуществ
4. **Риск неполной миграции** из-за недостатка ресурсов

**Меры по снижению рисков:**
1. Тщательное тестирование на каждом этапе
2. Постепенная миграция с возможностью отката
3. Мониторинг и алертинг
4. Автоматизированные тесты и CI/CD
5. Документирование всех изменений

### **Выбор первого модуля для миграции**

**Рекомендуемый модуль: Booking Service**

**Обоснование:**
1. **Высокая бизнес-ценность** - бронирования являются основной функцией системы
2. **Четкие границы** - относительно изолированная логика
3. **Частые изменения** - требует гибкости в разработке
4. **Масштабируемость** - пиковые нагрузки на бронирования
5. **Простота тестирования** - можно легко создать автономные тесты

**План миграции Booking Service:**
1. Создание отдельного сервиса с gRPC API
2. Настройка синхронной коммуникации с монолитом
3. Постепенное перенаправление трафика
4. Мониторинг и оптимизация
5. Полное отключение от монолита

### **Архитектурная диаграмма**

![Strangler Fig Pattern - C4 Architecture](http://www.plantuml.com/plantuml/proxy?cache=no&src=https://raw.githubusercontent.com/your-repo/msa-sprint2/main/tasks/task1/strangler-fig-c4.puml)

**Описание диаграммы:**

Диаграмма показывает архитектуру миграции с использованием паттерна Strangler Fig:

1. **Исходная C4 архитектура** - сохранена полностью с правильными цветами и стилями
2. **API Gateway** - точка входа, реализующая паттерн Strangler Fig
3. **Booking Service** - новый микросервис, выделенный из монолита
4. **Anti-Corruption Layer (ACL)** - защищает новый сервис от изменений в монолите
5. **Постепенная миграция** - трафик перенаправляется поэтапно (10% → 50% → 100%)
6. **Взаимодействие** - новый сервис обращается к сервисам монолита через ACL 